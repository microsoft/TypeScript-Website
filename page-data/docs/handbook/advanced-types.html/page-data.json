{"componentChunkName":"component---src-templates-handbook-tsx","path":"/docs/handbook/advanced-types.html","result":{"data":{"allSitePage":{"nodes":[{"path":"/dev-404-page/"},{"path":"/docs/handbook/advanced-types.html"},{"path":"/docs/handbook/basic-types.html"},{"path":"/docs/handbook/classes.html"},{"path":"/docs/handbook/compiler-options-in-msbuild.html"},{"path":"/docs/handbook/compiler-options.html"},{"path":"/docs/handbook/configuring-watch.html"},{"path":"/docs/handbook/declaration-merging.html"},{"path":"/docs/handbook/decorators.html"},{"path":"/docs/handbook/enums.html"},{"path":"/docs/handbook/functions.html"},{"path":"/docs/handbook/generics.html"},{"path":"/docs/handbook/integrating-with-build-tools.html"},{"path":"/docs/handbook/interfaces.html"},{"path":"/docs/handbook/iterators-and-generators.html"},{"path":"/docs/handbook/jsdoc-supported-types.html"},{"path":"/docs/handbook/jsx.html"},{"path":"/docs/handbook/literal-types.html"},{"path":"/docs/handbook/mixins.html"},{"path":"/docs/handbook/module-resolution.html"},{"path":"/docs/handbook/modules.html"},{"path":"/docs/handbook/namespaces-and-modules.html"},{"path":"/docs/handbook/namespaces.html"},{"path":"/docs/handbook/nightly-builds.html"},{"path":"/docs/handbook/project-references.html"},{"path":"/docs/handbook/symbols.html"},{"path":"/docs/handbook/intro.html"},{"path":"/docs/handbook/triple-slash-directives.html"},{"path":"/docs/handbook/type-checking-javascript-files.html"},{"path":"/docs/handbook/type-inference.html"},{"path":"/docs/handbook/type-compatibility.html"},{"path":"/docs/handbook/unions-and-intersections.html"},{"path":"/docs/handbook/utility-types.html"},{"path":"/docs/handbook/variable-declarations.html"},{"path":"/docs/handbook/declaration-files/consumption.html"},{"path":"/docs/handbook/declaration-files/by-example.html"},{"path":"/docs/handbook/declaration-files/dts-from-js.html"},{"path":"/docs/handbook/declaration-files/deep-dive.html"},{"path":"/docs/handbook/declaration-files/do-s-and-don-ts.html"},{"path":"/docs/handbook/declaration-files/introduction.html"},{"path":"/docs/handbook/declaration-files/publishing.html"},{"path":"/docs/handbook/declaration-files/library-structures.html"},{"path":"/docs/handbook/declaration-files/templates.html"},{"path":"/docs/handbook/release-notes/typescript-1-1.html"},{"path":"/docs/handbook/release-notes/typescript-1-3.html"},{"path":"/docs/handbook/release-notes/typescript-1-4.html"},{"path":"/docs/handbook/release-notes/typescript-1-5.html"},{"path":"/docs/handbook/release-notes/typescript-1-6.html"},{"path":"/docs/handbook/release-notes/typescript-1-7.html"},{"path":"/docs/handbook/release-notes/typescript-1-8.html"},{"path":"/docs/handbook/release-notes/typescript-2-0.html"},{"path":"/docs/handbook/release-notes/typescript-2-1.html"},{"path":"/docs/handbook/release-notes/typescript-2-2.html"},{"path":"/docs/handbook/release-notes/typescript-2-3.html"},{"path":"/docs/handbook/release-notes/typescript-2-4.html"},{"path":"/docs/handbook/release-notes/typescript-2-5.html"},{"path":"/docs/handbook/release-notes/typescript-2-6.html"},{"path":"/docs/handbook/release-notes/typescript-2-7.html"},{"path":"/docs/handbook/release-notes/typescript-2-8.html"},{"path":"/docs/handbook/release-notes/typescript-3-0.html"},{"path":"/docs/handbook/release-notes/typescript-3-1.html"},{"path":"/docs/handbook/release-notes/typescript-2-9.html"},{"path":"/docs/handbook/release-notes/typescript-3-2.html"},{"path":"/docs/handbook/release-notes/typescript-3-3.html"},{"path":"/docs/handbook/release-notes/typescript-3-4.html"},{"path":"/docs/handbook/release-notes/typescript-3-5.html"},{"path":"/docs/handbook/release-notes/typescript-3-6.html"},{"path":"/docs/handbook/release-notes/typescript-3-7.html"},{"path":"/docs/handbook/release-notes/typescript-3-8.html"},{"path":"/docs/handbook/release-notes/typescript-3-9.html"},{"path":"/docs/handbook/asp-net-core.html"},{"path":"/docs/handbook/dom-manipulation.html"},{"path":"/docs/handbook/angular.html"},{"path":"/docs/handbook/gulp.html"},{"path":"/docs/handbook/migrating-from-javascript.html"},{"path":"/docs/handbook/react.html"},{"path":"/docs/handbook/typescript-in-5-minutes-func.html"},{"path":"/docs/handbook/typescript-in-5-minutes.html"},{"path":"/docs/handbook/typescript-in-5-minutes-oop.html"},{"path":"/docs/handbook/typescript-tooling-in-5-minutes.html"},{"path":"/docs/handbook/typescript-from-scratch.html"},{"path":"/docs/handbook/tsconfig-json.html"},{"path":"/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/global-plugin-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/global-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-class-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-function-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-plugin-d-ts.html"},{"path":"/docs/handbook/declaration-files/templates/module-d-ts.html"},{"path":"/docs/handbook/release-notes/overview.html"},{"path":"/tsconfig"},{"path":"/en/tsconfig"},{"path":"/ja/tsconfig"},{"path":"/vo/tsconfig"},{"path":"/play"},{"path":"/en/play"},{"path":"/es/play"},{"path":"/fa/play"},{"path":"/ja/play"},{"path":"/vo/play"},{"path":"/zh/play"},{"path":"/play/3-7/fixits/big-number-literals.ts"},{"path":"/play/3-7/fixits/const-to-let.ts"},{"path":"/play/3-7/fixits/infer-from-usage-changes.ts"},{"path":"/play/3-7/syntax-and-messaging/flattened-error-reporting.ts"},{"path":"/play/3-7/syntax-and-messaging/nullish-coalescing.ts"},{"path":"/play/3-7/syntax-and-messaging/optional-chaining.ts"},{"path":"/play/3-7/types-and-code-flow/assertion-functions.ts"},{"path":"/play/3-7/types-and-code-flow/recursive-type-references.ts"},{"path":"/play/3-7/types-and-code-flow/uncalled-function-checks.ts"},{"path":"/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts"},{"path":"/play/3-8/jsdoc-improvements/accessibility-modifiers.js"},{"path":"/play/3-8/syntax-and-messaging/export-modules-from.ts"},{"path":"/play/3-8/syntax-and-messaging/private-class-fields.ts"},{"path":"/play/4-0/new-checks/class-constructor-code-flow.ts"},{"path":"/play/4-0/new-js-features/jsdoc-deprecated.ts"},{"path":"/play/4-0/new-js-features/logical-operators-and-assignment.ts"},{"path":"/play/4-0/new-js-features/nullish-coalescing.ts"},{"path":"/play/4-0/new-ts-features/named-tuples.ts"},{"path":"/play/4-0/new-ts-features/unknown-in-catch.ts"},{"path":"/play/4-0/new-ts-features/variadic-tuples.ts"},{"path":"/play/javascript/external-apis/typescript-with-deno.ts"},{"path":"/play/javascript/external-apis/typescript-with-node.js"},{"path":"/play/javascript/external-apis/typescript-with-web.js"},{"path":"/play/javascript/external-apis/typescript-with-webgl.js"},{"path":"/play/javascript/functions-with-javascript/function-chaining.ts"},{"path":"/play/javascript/functions-with-javascript/generic-functions.ts"},{"path":"/play/javascript/functions-with-javascript/typing-functions.ts"},{"path":"/play/javascript/helping-with-javascript/errors.ts"},{"path":"/play/javascript/helping-with-javascript/quick-fixes.ts"},{"path":"/play/javascript/javascript-essentials/code-flow.ts"},{"path":"/play/javascript/javascript-essentials/functions.ts"},{"path":"/play/javascript/javascript-essentials/hello-world.ts"},{"path":"/play/javascript/javascript-essentials/objects-and-arrays.ts"},{"path":"/play/javascript/modern-javascript/async-await.ts"},{"path":"/play/javascript/modern-javascript/immutability.ts"},{"path":"/play/javascript/modern-javascript/import-export.ts"},{"path":"/play/javascript/modern-javascript/jsdoc-support.js"},{"path":"/play/javascript/working-with-classes/classes-101.ts"},{"path":"/play/javascript/working-with-classes/generic-classes.ts"},{"path":"/play/javascript/working-with-classes/mixins.ts"},{"path":"/play/javascript/working-with-classes/this.ts"},{"path":"/play/playground/config/javascript-playgrounds.js"},{"path":"/play/playground/config/new-compiler-defaults.ts"},{"path":"/play/playground/language/automatic-type-acquisition.ts"},{"path":"/play/playground/language/fixits.ts"},{"path":"/play/playground/tooling/mobile-support.ts"},{"path":"/play/playground/tooling/sharable-urls.ts"},{"path":"/play/playground/tooling/typescript-versions.ts"},{"path":"/play/typescript/language/soundness.ts"},{"path":"/play/typescript/language/structural-typing.ts"},{"path":"/play/typescript/language/type-guards.ts"},{"path":"/play/typescript/language/type-widening-and-narrowing.ts"},{"path":"/play/typescript/language-extensions/enums.ts"},{"path":"/play/typescript/language-extensions/nominal-typing.ts"},{"path":"/play/typescript/language-extensions/types-vs-interfaces.ts"},{"path":"/play/typescript/meta-types/conditional-types.ts"},{"path":"/play/typescript/meta-types/discriminate-types.ts"},{"path":"/play/typescript/meta-types/indexed-types.ts"},{"path":"/play/typescript/meta-types/mapped-types.ts"},{"path":"/play/typescript/primitives/any.ts"},{"path":"/play/typescript/primitives/literals.ts"},{"path":"/play/typescript/primitives/union-and-intersection-types.ts"},{"path":"/play/typescript/primitives/unknown-and-never.ts"},{"path":"/play/typescript/type-primitives/built-in-utility-types.ts"},{"path":"/play/typescript/type-primitives/nullable-types.ts"},{"path":"/play/typescript/type-primitives/tuples.ts"},{"path":"/es/play/javascript/external-apis/typescript-with-deno.ts"},{"path":"/es/play/javascript/external-apis/typescript-with-node.js"},{"path":"/es/play/javascript/external-apis/typescript-with-web.js"},{"path":"/es/play/javascript/functions-with-javascript/function-chaining.ts"},{"path":"/es/play/javascript/functions-with-javascript/generic-functions.ts"},{"path":"/es/play/javascript/javascript-essentials/hello-world.ts"},{"path":"/es/play/javascript/javascript-essentials/objects-and-arrays.ts"},{"path":"/es/play/typescript/primitives/any.ts"},{"path":"/es/play/typescript/primitives/literals.ts"},{"path":"/es/play/typescript/primitives/union-and-intersection-types.ts"},{"path":"/es/play/typescript/primitives/unknown-and-never.ts"},{"path":"/es/play/typescript/type-primitives/built-in-utility-types.ts"},{"path":"/es/play/typescript/type-primitives/nullable-types.ts"},{"path":"/es/play/typescript/type-primitives/tuples.ts"},{"path":"/fa/play/javascript/javascript-essentials/hello-world.ts"},{"path":"/ja/play/3-7/fixits/big-number-literals.ts"},{"path":"/ja/play/3-7/fixits/const-to-let.ts"},{"path":"/ja/play/3-7/fixits/infer-from-usage-changes.ts"},{"path":"/ja/play/3-7/syntax-and-messaging/flattened-error-reporting.ts"},{"path":"/ja/play/3-7/syntax-and-messaging/nullish-coalescing.ts"},{"path":"/ja/play/3-7/syntax-and-messaging/optional-chaining.ts"},{"path":"/ja/play/javascript/external-apis/typescript-with-deno.ts"},{"path":"/ja/play/typescript/language-extensions/enums.ts"},{"path":"/ja/play/typescript/language-extensions/nominal-typing.ts"},{"path":"/ja/play/typescript/language-extensions/types-vs-interfaces.ts"},{"path":"/ja/play/typescript/type-primitives/built-in-utility-types.ts"},{"path":"/ja/play/typescript/type-primitives/nullable-types.ts"},{"path":"/ja/play/typescript/type-primitives/tuples.ts"},{"path":"/vo/play/javascript/javascript-essentials/code-flow.ts"},{"path":"/vo/play/javascript/javascript-essentials/functions.ts"},{"path":"/vo/play/javascript/javascript-essentials/hello-world.ts"},{"path":"/vo/play/javascript/javascript-essentials/objects-and-arrays.ts"},{"path":"/zh/play/javascript/external-apis/typescript-with-deno.ts"},{"path":"/zh/play/javascript/external-apis/typescript-with-node.js"},{"path":"/zh/play/javascript/external-apis/typescript-with-web.js"},{"path":"/zh/play/javascript/external-apis/typescript-with-webgl.js"},{"path":"/zh/play/javascript/functions-with-javascript/function-chaining.ts"},{"path":"/zh/play/javascript/functions-with-javascript/generic-functions.ts"},{"path":"/zh/play/javascript/functions-with-javascript/typing-functions.ts"},{"path":"/zh/play/javascript/helping-with-javascript/errors.ts"},{"path":"/zh/play/javascript/helping-with-javascript/quick-fixes.ts"},{"path":"/zh/play/javascript/javascript-essentials/code-flow.ts"},{"path":"/zh/play/javascript/javascript-essentials/functions.ts"},{"path":"/zh/play/javascript/javascript-essentials/hello-world.ts"},{"path":"/zh/play/javascript/javascript-essentials/objects-and-arrays.ts"},{"path":"/zh/play/javascript/modern-javascript/async-await.ts"},{"path":"/zh/play/javascript/modern-javascript/immutability.ts"},{"path":"/zh/play/javascript/modern-javascript/import-export.ts"},{"path":"/zh/play/javascript/modern-javascript/jsdoc-support.js"},{"path":"/zh/play/javascript/working-with-classes/classes-101.ts"},{"path":"/zh/play/javascript/working-with-classes/generic-classes.ts"},{"path":"/zh/play/javascript/working-with-classes/mixins.ts"},{"path":"/zh/play/javascript/working-with-classes/this.ts"},{"path":"/zh/play/playground/config/javascript-playgrounds.js"},{"path":"/zh/play/playground/config/new-compiler-defaults.ts"},{"path":"/zh/play/playground/language/automatic-type-acquisition.ts"},{"path":"/zh/play/playground/language/fixits.ts"},{"path":"/zh/play/playground/tooling/mobile-support.ts"},{"path":"/zh/play/playground/tooling/sharable-urls.ts"},{"path":"/zh/play/playground/tooling/typescript-versions.ts"},{"path":"/zh/play/typescript/language/soundness.ts"},{"path":"/zh/play/typescript/language/structural-typing.ts"},{"path":"/zh/play/typescript/language/type-guards.ts"},{"path":"/zh/play/typescript/language/type-widening-and-narrowing.ts"},{"path":"/zh/play/typescript/language-extensions/enums.ts"},{"path":"/zh/play/typescript/language-extensions/nominal-typing.ts"},{"path":"/zh/play/typescript/language-extensions/types-vs-interfaces.ts"},{"path":"/zh/play/typescript/meta-types/conditional-types.ts"},{"path":"/zh/play/typescript/meta-types/discriminate-types.ts"},{"path":"/zh/play/typescript/meta-types/indexed-types.ts"},{"path":"/zh/play/typescript/meta-types/mapped-types.ts"},{"path":"/zh/play/typescript/primitives/any.ts"},{"path":"/zh/play/typescript/primitives/literals.ts"},{"path":"/zh/play/typescript/primitives/union-and-intersection-types.ts"},{"path":"/zh/play/typescript/primitives/unknown-and-never.ts"},{"path":"/zh/play/typescript/type-primitives/built-in-utility-types.ts"},{"path":"/zh/play/typescript/type-primitives/nullable-types.ts"},{"path":"/zh/play/typescript/type-primitives/tuples.ts"},{"path":"/ja/play/typescript/primitives/literals.ts"},{"path":"/ja/play/typescript/primitives/union-and-intersection-types.ts"},{"path":"/ja/play/typescript/primitives/any.ts"},{"path":"/community"},{"path":"/es/community"},{"path":"/ja/community"},{"path":"/vo/community"},{"path":"/zh/community"},{"path":"/download"},{"path":"/es/download"},{"path":"/ja/download"},{"path":"/vo/download"},{"path":"/zh/download"},{"path":"/empty"},{"path":"/es/empty"},{"path":"/ja/empty"},{"path":"/vo/empty"},{"path":"/zh/empty"},{"path":"/"},{"path":"/es/"},{"path":"/ja/"},{"path":"/vo/"},{"path":"/zh/"},{"path":"/tools"},{"path":"/es/tools"},{"path":"/ja/tools"},{"path":"/vo/tools"},{"path":"/zh/tools"},{"path":"/why-create-typescript"},{"path":"/es/why-create-typescript"},{"path":"/ja/why-create-typescript"},{"path":"/vo/why-create-typescript"},{"path":"/zh/why-create-typescript"},{"path":"/docs/home"},{"path":"/es/docs/home"},{"path":"/ja/docs/home"},{"path":"/vo/docs/home"},{"path":"/zh/docs/home"},{"path":"/docs/handbook/"},{"path":"/es/docs/handbook/"},{"path":"/ja/docs/handbook/"},{"path":"/vo/docs/handbook/"},{"path":"/zh/docs/handbook/"},{"path":"/branding/"},{"path":"/dev/bug-workbench/"},{"path":"/dev/playground-plugins/"},{"path":"/dev/sandbox/"},{"path":"/dev/twoslash/"},{"path":"/dev/typescript-vfs/"},{"path":"/upcoming/"}]},"markdownRemark":{"id":"3891628f-85fb-5e80-bcfb-9c0b5de35bf8","excerpt":"This page lists some of the more advanced ways in which you can model types, it works in tandem with the Utility Types doc which includes types which are…","html":"<p>This page lists some of the more advanced ways in which you can model types, it works in tandem with the <a href=\"/docs/handbook/utility-types.html\">Utility Types</a> doc which includes types which are included in TypeScript and available globally.</p>\n<h1 id=\"type-guards-and-differentiating-types\" style=\"position:relative;\"><a href=\"#type-guards-and-differentiating-types\" aria-label=\"type guards and differentiating types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Guards and Differentiating Types</h1>\n<p>Union types are useful for modeling situations when values can overlap in the types they can take on.\nWhat happens when we need to know specifically whether we have a <code>Fish</code>?\nA common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member.\nAs we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">pet </span><span style=\"color: #000000\">= getSmallPet();</span>\n\n<span style=\"color: #008000\">// Each of these property accesses will cause an error</span>\n<span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">swim</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\">.swim();</span>\n<span style=\"color: #000000\">} </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">fly</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\">.fly();</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>To get the same code working, we’ll need to use a type assertion:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">pet </span><span style=\"color: #000000\">= getSmallPet();</span>\n\n<span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> ((</span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> Fish).</span><span style=\"color: #1A1A1A\">swim</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  (</span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> Fish).swim();</span>\n<span style=\"color: #000000\">} </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> ((</span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> Bird).</span><span style=\"color: #1A1A1A\">fly</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  (</span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> Bird).fly();</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<h2 id=\"user-defined-type-guards\" style=\"position:relative;\"><a href=\"#user-defined-type-guards\" aria-label=\"user defined type guards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>User-Defined Type Guards</h2>\n<p>Notice that we had to use type assertions several times.\nIt would be much better if once we performed the check, we could know the type of <code>pet</code> within each branch.</p>\n<p>It just so happens that TypeScript has something called a <em>type guard</em>.\nA type guard is some expression that performs a runtime check that guarantees the type in some scope.</p>\n<h3 id=\"using-type-predicates\" style=\"position:relative;\"><a href=\"#using-type-predicates\" aria-label=\"using type predicates permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using type predicates</h3>\n<p>To define a type guard, we simply need to define a function whose return type is a <em>type predicate</em>:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> isFish(</span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\">: Fish | Bird): pet </span><span style=\"color: #0000FF\">is</span><span style=\"color: #000000\"> Fish {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> Fish).</span><span style=\"color: #1A1A1A\">swim</span><span style=\"color: #000000\"> !== </span><span style=\"color: #0000FF\">undefined</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p><code>pet is Fish</code> is our type predicate in this example.\nA predicate takes the form <code>parameterName is Type</code>, where <code>parameterName</code> must be the name of a parameter from the current function signature.</p>\n<p>Any time <code>isFish</code> is called with some variable, TypeScript will <em>narrow</em> that variable to that specific type if the original type is compatible.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #008000\">// Both calls to 'swim' and 'fly' are now okay.</span>\n\n<span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (isFish(</span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\">)) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\">.swim();</span>\n<span style=\"color: #000000\">} </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\">.fly();</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Notice that TypeScript not only knows that <code>pet</code> is a <code>Fish</code> in the <code>if</code> branch;\nit also knows that in the <code>else</code> branch, you <em>don’t</em> have a <code>Fish</code>, so you must have a <code>Bird</code>.</p>\n<h3 id=\"using-the-in-operator\" style=\"position:relative;\"><a href=\"#using-the-in-operator\" aria-label=\"using the in operator permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using the <code>in</code> operator</h3>\n<p>The <code>in</code> operator now acts as a narrowing expression for types.</p>\n<p>For a <code>n in x</code> expression, where <code>n</code> is a string literal or string literal type and <code>x</code> is a union type, the “true” branch narrows to types which have an optional or required property <code>n</code>, and the “false” branch narrows to types which have an optional or missing property <code>n</code>.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> move(</span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\">: Fish | Bird) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #A31515\">\"swim\"</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\">.swim();</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">pet</span><span style=\"color: #000000\">.fly();</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<h2 id=\"typeof-type-guards\" style=\"position:relative;\"><a href=\"#typeof-type-guards\" aria-label=\"typeof type guards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>typeof</code> type guards</h2>\n<p>Let’s go back and write the code for the version of <code>padLeft</code> that uses union types.\nWe could write it with type predicates as follows:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> isNumber(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: any): x </span><span style=\"color: #0000FF\">is</span><span style=\"color: #000000\"> number {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">typeof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"number\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> isString(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: any): x </span><span style=\"color: #0000FF\">is</span><span style=\"color: #000000\"> string {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">typeof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"string\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> padLeft(</span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">: string, </span><span style=\"color: #1A1A1A\">padding</span><span style=\"color: #000000\">: string | number) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (isNumber(</span><span style=\"color: #1A1A1A\">padding</span><span style=\"color: #000000\">)) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> Array(</span><span style=\"color: #1A1A1A\">padding</span><span style=\"color: #000000\"> + </span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">).join(</span><span style=\"color: #A31515\">\" \"</span><span style=\"color: #000000\">) + </span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (isString(</span><span style=\"color: #1A1A1A\">padding</span><span style=\"color: #000000\">)) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">padding</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">throw</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> Error(</span><span style=\"color: #A31515\">`Expected string or number, got '</span><span style=\"color: #0000FF\">${</span><span style=\"color: #1A1A1A\">padding</span><span style=\"color: #0000FF\">}</span><span style=\"color: #A31515\">'.`</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>However, having to define a function to figure out if a type is a primitive is kind of a pain.\nLuckily, you don’t need to abstract <code>typeof x === \"number\"</code> into its own function because TypeScript will recognize it as a type guard on its own.\nThat means we could just write these checks inline.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> padLeft(</span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">: string, </span><span style=\"color: #1A1A1A\">padding</span><span style=\"color: #000000\">: string | number) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #0000FF\">typeof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">padding</span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"number\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> Array(</span><span style=\"color: #1A1A1A\">padding</span><span style=\"color: #000000\"> + </span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">).join(</span><span style=\"color: #A31515\">\" \"</span><span style=\"color: #000000\">) + </span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #0000FF\">typeof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">padding</span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"string\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">padding</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">throw</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> Error(</span><span style=\"color: #A31515\">`Expected string or number, got '</span><span style=\"color: #0000FF\">${</span><span style=\"color: #1A1A1A\">padding</span><span style=\"color: #0000FF\">}</span><span style=\"color: #A31515\">'.`</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>These <em><code>typeof</code> type guards</em> are recognized in two different forms: <code>typeof v === \"typename\"</code> and <code>typeof v !== \"typename\"</code>, where <code>\"typename\"</code> must be <code>\"number\"</code>, <code>\"string\"</code>, <code>\"boolean\"</code>, or <code>\"symbol\"</code>.\nWhile TypeScript won’t stop you from comparing to other strings, the language won’t recognize those expressions as type guards.</p>\n<h2 id=\"instanceof-type-guards\" style=\"position:relative;\"><a href=\"#instanceof-type-guards\" aria-label=\"instanceof type guards permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>instanceof</code> type guards</h2>\n<p>If you’ve read about <code>typeof</code> type guards and are familiar with the <code>instanceof</code> operator in JavaScript, you probably have some idea of what this section is about.</p>\n<p><em><code>instanceof</code> type guards</em> are a way of narrowing types using their constructor function.\nFor instance, let’s borrow our industrial string-padder example from earlier:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Padder {</span>\n<span style=\"color: #000000\">  getPaddingString(): string;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> SpaceRepeatingPadder </span><span style=\"color: #0000FF\">implements</span><span style=\"color: #000000\"> Padder {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">(</span><span style=\"color: #0000FF\">private</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">numSpaces</span><span style=\"color: #000000\">: number) {}</span>\n<span style=\"color: #000000\">  getPaddingString() {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> Array(</span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">numSpaces</span><span style=\"color: #000000\"> + </span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">).join(</span><span style=\"color: #A31515\">\" \"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> StringPadder </span><span style=\"color: #0000FF\">implements</span><span style=\"color: #000000\"> Padder {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">(</span><span style=\"color: #0000FF\">private</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">: string) {}</span>\n<span style=\"color: #000000\">  getPaddingString() {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.value;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> getRandomPadder() {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> Math.random() &lt; </span><span style=\"color: #09835A\">0.5</span>\n<span style=\"color: #000000\">    ? </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> SpaceRepeatingPadder(</span><span style=\"color: #09835A\">4</span><span style=\"color: #000000\">)</span>\n<span style=\"color: #000000\">    : </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> StringPadder(</span><span style=\"color: #A31515\">\"  \"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #008000\">// Type is 'SpaceRepeatingPadder | StringPadder'</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">padder</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> Padder </span><span style=\"color: #000000\">= getRandomPadder();</span>\n\n<span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">padder</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">instanceof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">SpaceRepeatingPadder</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">padder</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// type narrowed to 'SpaceRepeatingPadder'</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">padder</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">instanceof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">StringPadder</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">padder</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// type narrowed to 'StringPadder'</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>The right side of the <code>instanceof</code> needs to be a constructor function, and TypeScript will narrow down to:</p>\n<ol>\n<li>the type of the function’s <code>prototype</code> property if its type is not <code>any</code></li>\n<li>the union of types returned by that type’s construct signatures</li>\n</ol>\n<p>in that order.</p>\n<h1 id=\"nullable-types\" style=\"position:relative;\"><a href=\"#nullable-types\" aria-label=\"nullable types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Nullable types</h1>\n<p>TypeScript has two special types, <code>null</code> and <code>undefined</code>, that have the values null and undefined respectively.\nWe mentioned these briefly in <a href=\"/docs/handbook/basic-types.html\">the Basic Types section</a>.\nBy default, the type checker considers <code>null</code> and <code>undefined</code> assignable to anything.\nEffectively, <code>null</code> and <code>undefined</code> are valid values of every type.\nThat means it’s not possible to <em>stop</em> them from being assigned to any type, even when you would like to prevent it.\nThe inventor of <code>null</code>, Tony Hoare, calls this his <a href=\"https://wikipedia.org/wiki/Null_pointer#History\">“billion dollar mistake”</a>.</p>\n<p>The <code>--strictNullChecks</code> flag fixes this: when you declare a variable, it doesn’t automatically include <code>null</code> or <code>undefined</code>.\nYou can include them explicitly using a union type:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s </span><span style=\"color: #000000\">= </span><span style=\"color: #A31515\">\"foo\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">null</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// error, 'null' is not assignable to 'string'</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">sn</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> string </span><span style=\"color: #000000\">|</span><span style=\"color: #1A1A1A\"> null </span><span style=\"color: #000000\">= </span><span style=\"color: #A31515\">\"bar\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #1A1A1A\">sn</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">null</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// ok</span>\n\n<span style=\"color: #1A1A1A\">sn</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">undefined</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// error, 'undefined' is not assignable to 'string | null'</span></code></div></pre>\n<p>Note that TypeScript treats <code>null</code> and <code>undefined</code> differently in order to match JavaScript semantics.\n<code>string | null</code> is a different type than <code>string | undefined</code> and <code>string | undefined | null</code>.</p>\n<p>From TypeScript 3.7 and onwards, you can use <a href=\"/docs/handbook/release-notes/typescript-3-7.html#optional-chaining\">optional chaining</a> to simplify working with nullable types.</p>\n<h2 id=\"optional-parameters-and-properties\" style=\"position:relative;\"><a href=\"#optional-parameters-and-properties\" aria-label=\"optional parameters and properties permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Optional parameters and properties</h2>\n<p>With <code>--strictNullChecks</code>, an optional parameter automatically adds <code>| undefined</code>:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> f(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: number, </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">?: number) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> + (</span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\"> || </span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #000000\">f(</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">f(</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">f(</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\">undefined</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">f(</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\">null</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// error, 'null' is not assignable to 'number | undefined'</span></code></div></pre>\n<p>The same is true for optional properties:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> C {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">?: number;</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">c </span><span style=\"color: #000000\">= </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> C();</span>\n<span style=\"color: #1A1A1A\">c</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> = </span><span style=\"color: #09835A\">12</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #1A1A1A\">c</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">undefined</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// error, 'undefined' is not assignable to 'number'</span>\n<span style=\"color: #1A1A1A\">c</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\"> = </span><span style=\"color: #09835A\">13</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #1A1A1A\">c</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">undefined</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// ok</span>\n<span style=\"color: #1A1A1A\">c</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">null</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// error, 'null' is not assignable to 'number | undefined'</span></code></div></pre>\n<h2 id=\"type-guards-and-type-assertions\" style=\"position:relative;\"><a href=\"#type-guards-and-type-assertions\" aria-label=\"type guards and type assertions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type guards and type assertions</h2>\n<p>Since nullable types are implemented with a union, you need to use a type guard to get rid of the <code>null</code>.\nFortunately, this is the same code you’d write in JavaScript:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> f(</span><span style=\"color: #1A1A1A\">sn</span><span style=\"color: #000000\">: string | null): string {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">sn</span><span style=\"color: #000000\"> == </span><span style=\"color: #0000FF\">null</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"default\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">sn</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>The <code>null</code> elimination is pretty obvious here, but you can use terser operators too:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> f(</span><span style=\"color: #1A1A1A\">sn</span><span style=\"color: #000000\">: string | null): string {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">sn</span><span style=\"color: #000000\"> || </span><span style=\"color: #A31515\">\"default\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>In cases where the compiler can’t eliminate <code>null</code> or <code>undefined</code>, you can use the type assertion operator to manually remove them.\nThe syntax is postfix <code>!</code>: <code>identifier!</code> removes <code>null</code> and <code>undefined</code> from the type of <code>identifier</code>:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> broken(</span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\">: string | null): string {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> postfix(</span><span style=\"color: #1A1A1A\">epithet</span><span style=\"color: #000000\">: string) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\">.charAt(</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">) + </span><span style=\"color: #A31515\">\".  the \"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">epithet</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// error, 'name' is possibly null</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\"> || </span><span style=\"color: #A31515\">\"Bob\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> postfix(</span><span style=\"color: #A31515\">\"great\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> fixed(</span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\">: string | null): string {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> postfix(</span><span style=\"color: #1A1A1A\">epithet</span><span style=\"color: #000000\">: string) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\">!.charAt(</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">) + </span><span style=\"color: #A31515\">\".  the \"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">epithet</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// ok</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\"> || </span><span style=\"color: #A31515\">\"Bob\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> postfix(</span><span style=\"color: #A31515\">\"great\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>The example uses a nested function here because the compiler can’t eliminate nulls inside a nested function (except immediately-invoked function expressions).\nThat’s because it can’t track all calls to the nested function, especially if you return it from the outer function.\nWithout knowing where the function is called, it can’t know what the type of <code>name</code> will be at the time the body executes.</p>\n<h1 id=\"type-aliases\" style=\"position:relative;\"><a href=\"#type-aliases\" aria-label=\"type aliases permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type Aliases</h1>\n<p>Type aliases create a new name for a type.\nType aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you’d otherwise have to write by hand.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Name = string;</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> NameResolver = () </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> string;</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> NameOrResolver = Name | NameResolver;</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> getName(</span><span style=\"color: #1A1A1A\">n</span><span style=\"color: #000000\">: NameOrResolver): Name {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #0000FF\">typeof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">n</span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"string\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">n</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> n();</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Aliasing doesn’t actually create a new type - it creates a new <em>name</em> to refer to that type.\nAliasing a primitive is not terribly useful, though it can be used as a form of documentation.</p>\n<p>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Container&lt;T&gt; = { </span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">: T };</span></code></div></pre>\n<p>We can also have a type alias refer to itself in a property:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Tree&lt;T&gt; = {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">: T;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">left</span><span style=\"color: #000000\">: Tree&lt;T&gt;;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">right</span><span style=\"color: #000000\">: Tree&lt;T&gt;;</span>\n<span style=\"color: #000000\">};</span></code></div></pre>\n<p>Together with intersection types, we can make some pretty mind-bending types:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> LinkedList&lt;T&gt; = T & { </span><span style=\"color: #1A1A1A\">next</span><span style=\"color: #000000\">: LinkedList&lt;T&gt; };</span>\n\n<span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Person {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\">: string;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">var</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">people</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> LinkedList&lt;Person&gt;</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">var</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s </span><span style=\"color: #000000\">= </span><span style=\"color: #1A1A1A\">people</span><span style=\"color: #000000\">.name;</span>\n<span style=\"color: #0000FF\">var</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s </span><span style=\"color: #000000\">= </span><span style=\"color: #1A1A1A\">people</span><span style=\"color: #000000\">.next.name;</span>\n<span style=\"color: #0000FF\">var</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s </span><span style=\"color: #000000\">= </span><span style=\"color: #1A1A1A\">people</span><span style=\"color: #000000\">.next.next.name;</span>\n<span style=\"color: #0000FF\">var</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s </span><span style=\"color: #000000\">= </span><span style=\"color: #1A1A1A\">people</span><span style=\"color: #000000\">.next.next.next.name;</span></code></div></pre>\n<p>However, it’s not possible for a type alias to appear anywhere else on the right side of the declaration:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Yikes = Array&lt;Yikes&gt;; </span><span style=\"color: #008000\">// error</span></code></div></pre>\n<h2 id=\"interfaces-vs-type-aliases\" style=\"position:relative;\"><a href=\"#interfaces-vs-type-aliases\" aria-label=\"interfaces vs type aliases permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interfaces vs. Type Aliases</h2>\n<p>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</p>\n<p>One difference is that interfaces create a new name that is used everywhere.\nType aliases don’t create a new name — for instance, error messages won’t use the alias name.\nIn the code below, hovering over <code>interfaced</code> in an editor will show that it returns an <code>Interface</code>, but will show that <code>aliased</code> returns object literal type.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Alias = { </span><span style=\"color: #1A1A1A\">num</span><span style=\"color: #000000\">: number };</span>\n<span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Interface {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">num</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> aliased(</span><span style=\"color: #1A1A1A\">arg</span><span style=\"color: #000000\">: Alias): Alias;</span>\n<span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> interfaced(</span><span style=\"color: #1A1A1A\">arg</span><span style=\"color: #000000\">: Interface): Interface;</span></code></div></pre>\n<p>In older versions of TypeScript, type aliases couldn’t be extended or implemented from (nor could they extend/implement other types). As of version 2.7, type aliases can be extended by creating a new intersection type e.g. <code>type Cat = Animal &#x26; { purrs: true }</code>.</p>\n<p>Because <a href=\"https://wikipedia.org/wiki/Open/closed_principle\">an ideal property of software is being open to extension</a>, you should always use an interface over a type alias if possible.</p>\n<p>On the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.</p>\n<h1 id=\"string-literal-types\" style=\"position:relative;\"><a href=\"#string-literal-types\" aria-label=\"string literal types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>String Literal Types</h1>\n<p>String literal types allow you to specify the exact value a string must have.\nIn practice string literal types combine nicely with union types, type guards, and type aliases.\nYou can use these features together to get enum-like behavior with strings.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Easing = </span><span style=\"color: #A31515\">\"ease-in\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"ease-out\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"ease-in-out\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> UIElement {</span>\n<span style=\"color: #000000\">  animate(</span><span style=\"color: #1A1A1A\">dx</span><span style=\"color: #000000\">: number, </span><span style=\"color: #1A1A1A\">dy</span><span style=\"color: #000000\">: number, </span><span style=\"color: #1A1A1A\">easing</span><span style=\"color: #000000\">: Easing) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">easing</span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"ease-in\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">    } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">easing</span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"ease-out\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">easing</span><span style=\"color: #000000\"> === </span><span style=\"color: #A31515\">\"ease-in-out\"</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    } </span><span style=\"color: #0000FF\">else</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #008000\">// error! should not pass null or undefined.</span>\n<span style=\"color: #000000\">    }</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">button </span><span style=\"color: #000000\">= </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> UIElement();</span>\n<span style=\"color: #1A1A1A\">button</span><span style=\"color: #000000\">.animate(</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"ease-in\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #1A1A1A\">button</span><span style=\"color: #000000\">.animate(</span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">, </span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"uneasy\"</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// error: \"uneasy\" is not allowed here</span></code></div></pre>\n<p>You can pass any of the three allowed strings, but any other string will give the error</p>\n<pre><code>Argument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\n</code></pre>\n<p>String literal types can be used in the same way to distinguish overloads:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> createElement(</span><span style=\"color: #1A1A1A\">tagName</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"img\"</span><span style=\"color: #000000\">): HTMLImageElement;</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> createElement(</span><span style=\"color: #1A1A1A\">tagName</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"input\"</span><span style=\"color: #000000\">): HTMLInputElement;</span>\n<span style=\"color: #008000\">// ... more overloads ...</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> createElement(</span><span style=\"color: #1A1A1A\">tagName</span><span style=\"color: #000000\">: string): Element {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ... code goes here ...</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<h1 id=\"numeric-literal-types\" style=\"position:relative;\"><a href=\"#numeric-literal-types\" aria-label=\"numeric literal types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Numeric Literal Types</h1>\n<p>TypeScript also has numeric literal types.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> rollDice(): </span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\"> | </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\"> | </span><span style=\"color: #09835A\">3</span><span style=\"color: #000000\"> | </span><span style=\"color: #09835A\">4</span><span style=\"color: #000000\"> | </span><span style=\"color: #09835A\">5</span><span style=\"color: #000000\"> | </span><span style=\"color: #09835A\">6</span><span style=\"color: #000000\"> {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ...</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>These are seldom written explicitly, but they can be useful when narrowing issues and can catch bugs:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> foo(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: number) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">if</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> !== </span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\"> || </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> !== </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #008000\">//         ~~~~~~~</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #008000\">// Operator '!==' cannot be applied to types '1' and '2'.</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>In other words, <code>x</code> must be <code>1</code> when it gets compared to <code>2</code>, meaning that the above check is making an invalid comparison.</p>\n<h1 id=\"enum-member-types\" style=\"position:relative;\"><a href=\"#enum-member-types\" aria-label=\"enum member types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Enum Member Types</h1>\n<p>As mentioned in <a href=\"./enums.html#union-enums-and-enum-member-types\">our section on enums</a>, enum members have types when every member is literal-initialized.</p>\n<p>Much of the time when we talk about “singleton types”, we’re referring to both enum member types as well as numeric/string literal types, though many users will use “singleton types” and “literal types” interchangeably.</p>\n<h1 id=\"discriminated-unions\" style=\"position:relative;\"><a href=\"#discriminated-unions\" aria-label=\"discriminated unions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Discriminated Unions</h1>\n<p>You can combine singleton types, union types, type guards, and type aliases to build an advanced pattern called <em>discriminated unions</em>, also known as <em>tagged unions</em> or <em>algebraic data types</em>.\nDiscriminated unions are useful in functional programming.\nSome languages automatically discriminate unions for you; TypeScript instead builds on JavaScript patterns as they exist today.\nThere are three ingredients:</p>\n<ol>\n<li>Types that have a common, singleton type property — the <em>discriminant</em>.</li>\n<li>A type alias that takes the union of those types — the <em>union</em>.</li>\n<li>Type guards on the common property.</li>\n</ol>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Square {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">kind</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"square\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">size</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Rectangle {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">kind</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"rectangle\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">width</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">height</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Circle {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">kind</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"circle\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">radius</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>First we declare the interfaces we will union.\nEach interface has a <code>kind</code> property with a different string literal type.\nThe <code>kind</code> property is called the <em>discriminant</em> or <em>tag</em>.\nThe other properties are specific to each interface.\nNotice that the interfaces are currently unrelated.\nLet’s put them into a union:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Shape = Square | Rectangle | Circle;</span></code></div></pre>\n<p>Now let’s use the discriminated union:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> area(</span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">: Shape) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">switch</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">kind</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">case</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"square\"</span><span style=\"color: #000000\">:</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.size * </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.size;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">case</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"rectangle\"</span><span style=\"color: #000000\">:</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.height * </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.width;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">case</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"circle\"</span><span style=\"color: #000000\">:</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> Math.PI * </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">radius</span><span style=\"color: #000000\"> ** </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<h2 id=\"exhaustiveness-checking\" style=\"position:relative;\"><a href=\"#exhaustiveness-checking\" aria-label=\"exhaustiveness checking permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Exhaustiveness checking</h2>\n<p>We would like the compiler to tell us when we don’t cover all variants of the discriminated union.\nFor example, if we add <code>Triangle</code> to <code>Shape</code>, we need to update <code>area</code> as well:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Shape = Square | Rectangle | Circle | Triangle;</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> area(</span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">: Shape) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">switch</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">kind</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">case</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"square\"</span><span style=\"color: #000000\">:</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.size * </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.size;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">case</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"rectangle\"</span><span style=\"color: #000000\">:</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.height * </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.width;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">case</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"circle\"</span><span style=\"color: #000000\">:</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> Math.PI * </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">radius</span><span style=\"color: #000000\"> ** </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// should error here - we didn't handle case \"triangle\"</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>There are two ways to do this.\nThe first is to turn on <code>--strictNullChecks</code> and specify a return type:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> area(</span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">: Shape): number {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// error: returns number | undefined</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">switch</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">kind</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">case</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"square\"</span><span style=\"color: #000000\">:</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.size * </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.size;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">case</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"rectangle\"</span><span style=\"color: #000000\">:</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.height * </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.width;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">case</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"circle\"</span><span style=\"color: #000000\">:</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> Math.PI * </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">radius</span><span style=\"color: #000000\"> ** </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Because the <code>switch</code> is no longer exhaustive, TypeScript is aware that the function could sometimes return <code>undefined</code>.\nIf you have an explicit return type <code>number</code>, then you will get an error that the return type is actually <code>number | undefined</code>.\nHowever, this method is quite subtle and, besides, <code>--strictNullChecks</code> does not always work with old code.</p>\n<p>The second method uses the <code>never</code> type that the compiler uses to check for exhaustiveness:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> assertNever(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: never): never {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">throw</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> Error(</span><span style=\"color: #A31515\">\"Unexpected object: \"</span><span style=\"color: #000000\"> + </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> area(</span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">: Shape) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">switch</span><span style=\"color: #000000\"> (</span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">kind</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">case</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"square\"</span><span style=\"color: #000000\">:</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.size * </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.size;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">case</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"rectangle\"</span><span style=\"color: #000000\">:</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.height * </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.width;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">case</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"circle\"</span><span style=\"color: #000000\">:</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> Math.PI * </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">.</span><span style=\"color: #1A1A1A\">radius</span><span style=\"color: #000000\"> ** </span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">default</span><span style=\"color: #000000\">:</span>\n<span style=\"color: #000000\">      </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> assertNever(</span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// error here if there are missing cases</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Here, <code>assertNever</code> checks that <code>s</code> is of type <code>never</code> — the type that’s left after all other cases have been removed.\nIf you forget a case, then <code>s</code> will have a real type and you will get a type error.\nThis method requires you to define an extra function, but it’s much more obvious when you forget it.</p>\n<h1 id=\"polymorphic-this-types\" style=\"position:relative;\"><a href=\"#polymorphic-this-types\" aria-label=\"polymorphic this types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Polymorphic <code>this</code> types</h1>\n<p>A polymorphic <code>this</code> type represents a type that is the <em>subtype</em> of the containing class or interface.\nThis is called <em>F</em>-bounded polymorphism.\nThis makes hierarchical fluent interfaces much easier to express, for example.\nTake a simple calculator that returns <code>this</code> after each operation:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> BasicCalculator {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">public</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">(</span><span style=\"color: #0000FF\">protected</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">: number = </span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">) {}</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">public</span><span style=\"color: #000000\"> currentValue(): number {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.value;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">public</span><span style=\"color: #000000\"> add(</span><span style=\"color: #1A1A1A\">operand</span><span style=\"color: #000000\">: number): this {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.value += </span><span style=\"color: #1A1A1A\">operand</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">public</span><span style=\"color: #000000\"> multiply(</span><span style=\"color: #1A1A1A\">operand</span><span style=\"color: #000000\">: number): this {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.value *= </span><span style=\"color: #1A1A1A\">operand</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ... other operations go here ...</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">v </span><span style=\"color: #000000\">= </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> BasicCalculator(</span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">)</span>\n<span style=\"color: #000000\">  .multiply(</span><span style=\"color: #09835A\">5</span><span style=\"color: #000000\">)</span>\n<span style=\"color: #000000\">  .add(</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">)</span>\n<span style=\"color: #000000\">  .currentValue();</span></code></div></pre>\n<p>Since the class uses <code>this</code> types, you can extend it and the new class can use the old methods with no changes.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> ScientificCalculator </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> BasicCalculator {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">public</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">(</span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\"> = </span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">super</span><span style=\"color: #000000\">(</span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">public</span><span style=\"color: #000000\"> sin() {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.value = Math.sin(</span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.value);</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ... other operations go here ...</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">v </span><span style=\"color: #000000\">= </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> ScientificCalculator(</span><span style=\"color: #09835A\">2</span><span style=\"color: #000000\">)</span>\n<span style=\"color: #000000\">  .multiply(</span><span style=\"color: #09835A\">5</span><span style=\"color: #000000\">)</span>\n<span style=\"color: #000000\">  .sin()</span>\n<span style=\"color: #000000\">  .add(</span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">)</span>\n<span style=\"color: #000000\">  .currentValue();</span></code></div></pre>\n<p>Without <code>this</code> types, <code>ScientificCalculator</code> would not have been able to extend <code>BasicCalculator</code> and keep the fluent interface.\n<code>multiply</code> would have returned <code>BasicCalculator</code>, which doesn’t have the <code>sin</code> method.\nHowever, with <code>this</code> types, <code>multiply</code> returns <code>this</code>, which is <code>ScientificCalculator</code> here.</p>\n<h1 id=\"index-types\" style=\"position:relative;\"><a href=\"#index-types\" aria-label=\"index types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Index types</h1>\n<p>With index types, you can get the compiler to check code that uses dynamic property names.\nFor example, a common JavaScript pattern is to pick a subset of properties from an object:</p>\n<pre class=\"shiki\"><div class=\"language-id\">js</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> pluck(</span><span style=\"color: #1A1A1A\">o</span><span style=\"color: #000000\">, </span><span style=\"color: #1A1A1A\">propertyNames</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">propertyNames</span><span style=\"color: #000000\">.map(</span><span style=\"color: #1A1A1A\">n</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">o</span><span style=\"color: #000000\">[</span><span style=\"color: #1A1A1A\">n</span><span style=\"color: #000000\">]);</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Here’s how you would write and use this function in TypeScript, using the <strong>index type query</strong> and <strong>indexed access</strong> operators:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> pluck&lt;T, K </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #000000\"> T&gt;(</span><span style=\"color: #1A1A1A\">o</span><span style=\"color: #000000\">: T, </span><span style=\"color: #1A1A1A\">propertyNames</span><span style=\"color: #000000\">: K[]): T[K][] {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">propertyNames</span><span style=\"color: #000000\">.map(</span><span style=\"color: #1A1A1A\">n</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">o</span><span style=\"color: #000000\">[</span><span style=\"color: #1A1A1A\">n</span><span style=\"color: #000000\">]);</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Car {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">manufacturer</span><span style=\"color: #000000\">: string;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">model</span><span style=\"color: #000000\">: string;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">year</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">taxi</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> Car </span><span style=\"color: #000000\">= {</span>\n<span style=\"color: #000000\">  manufacturer: </span><span style=\"color: #A31515\">\"Toyota\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  model: </span><span style=\"color: #A31515\">\"Camry\"</span><span style=\"color: #000000\">,</span>\n<span style=\"color: #000000\">  year: </span><span style=\"color: #09835A\">2014</span>\n<span style=\"color: #000000\">};</span>\n\n<span style=\"color: #008000\">// Manufacturer and model are both of type string,</span>\n<span style=\"color: #008000\">// so we can pluck them both into a typed string array</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">makeAndModel</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> string[] </span><span style=\"color: #000000\">= pluck(</span><span style=\"color: #1A1A1A\">taxi</span><span style=\"color: #000000\">, [</span><span style=\"color: #A31515\">\"manufacturer\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"model\"</span><span style=\"color: #000000\">]);</span>\n\n<span style=\"color: #008000\">// If we try to pluck model and year, we get an</span>\n<span style=\"color: #008000\">// array of a union type: (string | number)[]</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">modelYear </span><span style=\"color: #000000\">= pluck(</span><span style=\"color: #1A1A1A\">taxi</span><span style=\"color: #000000\">, [</span><span style=\"color: #A31515\">\"model\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"year\"</span><span style=\"color: #000000\">]);</span></code></div></pre>\n<p>The compiler checks that <code>manufacturer</code> and <code>model</code> are actually properties on <code>Car</code>.\nThe example introduces a couple of new type operators.\nFirst is <code>keyof T</code>, the <strong>index type query operator</strong>.\nFor any type <code>T</code>, <code>keyof T</code> is the union of known, public property names of <code>T</code>.\nFor example:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">carProps</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> </span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #1A1A1A\"> Car</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// the union of ('manufacturer' | 'model' | 'year')</span></code></div></pre>\n<p><code>keyof Car</code> is completely interchangeable with <code>'manufacturer' | 'model' | 'year'</code>.\nThe difference is that if you add another property to <code>Car</code>, say <code>ownersAddress: string</code>, then <code>keyof Car</code> will automatically update to be <code>'manufacturer' | 'model' | 'year' | 'ownersAddress'</code>.\nAnd you can use <code>keyof</code> in generic contexts like <code>pluck</code>, where you can’t possibly know the property names ahead of time.\nThat means the compiler will check that you pass the right set of property names to <code>pluck</code>:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #008000\">// error, 'unknown' is not in 'manufacturer' | 'model' | 'year'</span>\n<span style=\"color: #000000\">pluck(</span><span style=\"color: #1A1A1A\">taxi</span><span style=\"color: #000000\">, [</span><span style=\"color: #A31515\">'year'</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">'unknown'</span><span style=\"color: #000000\">]); /</span></code></div></pre>\n<p>The second operator is <code>T[K]</code>, the <strong>indexed access operator</strong>.\nHere, the type syntax reflects the expression syntax.\nThat means that <code>person['name']</code> has the type <code>Person['name']</code> — which in our example is just <code>string</code>.\nHowever, just like index type queries, you can use <code>T[K]</code> in a generic context, which is where its real power comes to life.\nYou just have to make sure that the type variable <code>K extends keyof T</code>.\nHere’s another example with a function named <code>getProperty</code>.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> getProperty&lt;T, K </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #000000\"> T&gt;(</span><span style=\"color: #1A1A1A\">o</span><span style=\"color: #000000\">: T, </span><span style=\"color: #1A1A1A\">propertyName</span><span style=\"color: #000000\">: K): T[K] {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">o</span><span style=\"color: #000000\">[</span><span style=\"color: #1A1A1A\">propertyName</span><span style=\"color: #000000\">]; </span><span style=\"color: #008000\">// o[propertyName] is of type T[K]</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>In <code>getProperty</code>, <code>o: T</code> and <code>propertyName: K</code>, so that means <code>o[propertyName]: T[K]</code>.\nOnce you return the <code>T[K]</code> result, the compiler will instantiate the actual type of the key, so the return type of <code>getProperty</code> will vary according to which property you request.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> string </span><span style=\"color: #000000\">= getProperty(</span><span style=\"color: #1A1A1A\">taxi</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"manufacturer\"</span><span style=\"color: #000000\">);</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">year</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> number </span><span style=\"color: #000000\">= getProperty(</span><span style=\"color: #1A1A1A\">taxi</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"year\"</span><span style=\"color: #000000\">);</span>\n\n<span style=\"color: #008000\">// error, 'unknown' is not in 'manufacturer' | 'model' | 'year'</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">unknown </span><span style=\"color: #000000\">= getProperty(</span><span style=\"color: #1A1A1A\">taxi</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"unknown\"</span><span style=\"color: #000000\">);</span></code></div></pre>\n<h2 id=\"index-types-and-index-signatures\" style=\"position:relative;\"><a href=\"#index-types-and-index-signatures\" aria-label=\"index types and index signatures permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Index types and index signatures</h2>\n<p><code>keyof</code> and <code>T[K]</code> interact with index signatures. An index signature parameter type must be ‘string’ or ‘number’.\nIf you have a type with a string index signature, <code>keyof T</code> will be <code>string | number</code>\n(and not just <code>string</code>, since in JavaScript you can access an object property either\nby using strings (<code>object['42']</code>) or numbers (<code>object[42]</code>)).\nAnd <code>T[string]</code> is just the type of the index signature:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Dictionary&lt;T&gt; {</span>\n<span style=\"color: #000000\">  [</span><span style=\"color: #1A1A1A\">key</span><span style=\"color: #000000\">: string]: T;</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keys</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> </span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #1A1A1A\"> Dictionary&lt;number&gt;</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// string | number</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> Dictionary&lt;number&gt;[</span><span style=\"color: #A31515\">\"foo\"</span><span style=\"color: #1A1A1A\">]</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// number</span></code></div></pre>\n<p>If you have a type with a number index signature, <code>keyof T</code> will just be <code>number</code>.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Dictionary&lt;T&gt; {</span>\n<span style=\"color: #000000\">  [</span><span style=\"color: #1A1A1A\">key</span><span style=\"color: #000000\">: number]: T;</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keys</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> </span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #1A1A1A\"> Dictionary&lt;number&gt;</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// number</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> Dictionary&lt;number&gt;[</span><span style=\"color: #A31515\">\"foo\"</span><span style=\"color: #1A1A1A\">]</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Error, Property 'foo' does not exist on type 'Dictionary&lt;number&gt;'.</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> Dictionary&lt;number&gt;[</span><span style=\"color: #09835A\">42</span><span style=\"color: #1A1A1A\">]</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// number</span></code></div></pre>\n<h1 id=\"mapped-types\" style=\"position:relative;\"><a href=\"#mapped-types\" aria-label=\"mapped types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mapped types</h1>\n<p>A common task is to take an existing type and make each of its properties optional:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> PersonPartial {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\">?: string;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">age</span><span style=\"color: #000000\">?: number;</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Or we might want a readonly version:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> PersonReadonly {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">readonly</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\">: string;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">readonly</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">age</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types — <strong>mapped types</strong>.\nIn a mapped type, the new type transforms each property in the old type in the same way.\nFor example, you can make all properties of a type <code>readonly</code> or optional.\nHere are a couple of examples:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Readonly&lt;T&gt; = {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">readonly</span><span style=\"color: #000000\"> [P </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keyof</span><span style=\"color: #000000\"> T]: T[P];</span>\n<span style=\"color: #000000\">};</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Partial&lt;T&gt; = {</span>\n<span style=\"color: #000000\">  [P </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keyof</span><span style=\"color: #000000\"> T]?: T[P];</span>\n<span style=\"color: #000000\">};</span></code></div></pre>\n<p>And to use it:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> PersonPartial = Partial&lt;Person&gt;;</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> ReadonlyPerson = Readonly&lt;Person&gt;;</span></code></div></pre>\n<p>Note that this syntax describes a type rather than a member.\nIf you want to add members, you can use an intersection type:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #008000\">// Use this:</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> PartialWithNewMember&lt;T&gt; = {</span>\n<span style=\"color: #000000\">  [P </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keyof</span><span style=\"color: #000000\"> T]?: T[P];</span>\n<span style=\"color: #000000\">} & { </span><span style=\"color: #1A1A1A\">newMember</span><span style=\"color: #000000\">: boolean }</span>\n\n<span style=\"color: #008000\">// **Do not** use the following!</span>\n<span style=\"color: #008000\">// This is an error!</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> PartialWithNewMember&lt;T&gt; = {</span>\n<span style=\"color: #000000\">  [P </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keyof</span><span style=\"color: #000000\"> T]?: T[P];</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">newMember</span><span style=\"color: #000000\">: boolean;</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Let’s take a look at the simplest mapped type and its parts:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Keys = </span><span style=\"color: #A31515\">\"option1\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"option2\"</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Flags = { [K </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">Keys</span><span style=\"color: #000000\">]: boolean };</span></code></div></pre>\n<p>The syntax resembles the syntax for index signatures with a <code>for .. in</code> inside.\nThere are three parts:</p>\n<ol>\n<li>The type variable <code>K</code>, which gets bound to each property in turn.</li>\n<li>The string literal union <code>Keys</code>, which contains the names of properties to iterate over.</li>\n<li>The resulting type of the property.</li>\n</ol>\n<p>In this simple example, <code>Keys</code> is a hard-coded list of property names and the property type is always <code>boolean</code>, so this mapped type is equivalent to writing:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Flags = {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">option1</span><span style=\"color: #000000\">: boolean;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">option2</span><span style=\"color: #000000\">: boolean;</span>\n<span style=\"color: #000000\">};</span></code></div></pre>\n<p>Real applications, however, look like <code>Readonly</code> or <code>Partial</code> above.\nThey’re based on some existing type, and they transform the properties in some way.\nThat’s where <code>keyof</code> and indexed access types come in:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> NullablePerson = { [P </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keyof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">Person</span><span style=\"color: #000000\">]: Person[P] | null };</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> PartialPerson = { [P </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keyof</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">Person</span><span style=\"color: #000000\">]?: Person[P] };</span></code></div></pre>\n<p>But it’s more useful to have a general version.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Nullable&lt;T&gt; = { [P </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keyof</span><span style=\"color: #000000\"> T]: T[P] | null };</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Partial&lt;T&gt; = { [P </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keyof</span><span style=\"color: #000000\"> T]?: T[P] };</span></code></div></pre>\n<p>In these examples, the properties list is <code>keyof T</code> and the resulting type is some variant of <code>T[P]</code>.\nThis is a good template for any general use of mapped types.\nThat’s because this kind of transformation is <a href=\"https://wikipedia.org/wiki/Homomorphism\">homomorphic</a>, which means that the mapping applies only to properties of <code>T</code> and no others.\nThe compiler knows that it can copy all the existing property modifiers before adding any new ones.\nFor example, if <code>Person.name</code> was readonly, <code>Partial&#x3C;Person>.name</code> would be readonly and optional.</p>\n<p>Here’s one more example, in which <code>T[P]</code> is wrapped in a <code>Proxy&#x3C;T></code> class:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Proxy&lt;T&gt; = {</span>\n<span style=\"color: #000000\">  get(): T;</span>\n<span style=\"color: #000000\">  set(</span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">: T): void;</span>\n<span style=\"color: #000000\">};</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Proxify&lt;T&gt; = {</span>\n<span style=\"color: #000000\">  [P </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keyof</span><span style=\"color: #000000\"> T]: Proxy&lt;T[P]&gt;;</span>\n<span style=\"color: #000000\">};</span>\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> proxify&lt;T&gt;(</span><span style=\"color: #1A1A1A\">o</span><span style=\"color: #000000\">: T): Proxify&lt;T&gt; {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// ... wrap proxies ...</span>\n<span style=\"color: #000000\">}</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">proxyProps </span><span style=\"color: #000000\">= proxify(</span><span style=\"color: #1A1A1A\">props</span><span style=\"color: #000000\">);</span></code></div></pre>\n<p>Note that <code>Readonly&#x3C;T></code> and <code>Partial&#x3C;T></code> are so useful, they are included in TypeScript’s standard library along with <code>Pick</code> and <code>Record</code>:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Pick&lt;T, K </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #000000\"> T&gt; = {</span>\n<span style=\"color: #000000\">  [P </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> K]: T[P];</span>\n<span style=\"color: #000000\">};</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Record&lt;K </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #000000\"> any, T&gt; = {</span>\n<span style=\"color: #000000\">  [P </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> K]: T;</span>\n<span style=\"color: #000000\">};</span></code></div></pre>\n<p><code>Readonly</code>, <code>Partial</code> and <code>Pick</code> are homomorphic whereas <code>Record</code> is not.\nOne clue that <code>Record</code> is not homomorphic is that it doesn’t take an input type to copy properties from:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> ThreeStringProps = Record&lt;</span><span style=\"color: #A31515\">\"prop1\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"prop2\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"prop3\"</span><span style=\"color: #000000\">, string&gt;;</span></code></div></pre>\n<p>Non-homomorphic types are essentially creating new properties, so they can’t copy property modifiers from anywhere.</p>\n<h2 id=\"inference-from-mapped-types\" style=\"position:relative;\"><a href=\"#inference-from-mapped-types\" aria-label=\"inference from mapped types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Inference from mapped types</h2>\n<p>Now that you know how to wrap the properties of a type, the next thing you’ll want to do is unwrap them.\nFortunately, that’s pretty easy:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> unproxify&lt;T&gt;(</span><span style=\"color: #1A1A1A\">t</span><span style=\"color: #000000\">: Proxify&lt;T&gt;): T {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">result </span><span style=\"color: #000000\">= {} </span><span style=\"color: #0000FF\">as</span><span style=\"color: #000000\"> T;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">for</span><span style=\"color: #000000\"> (</span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">k</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">t</span><span style=\"color: #000000\">) {</span>\n<span style=\"color: #000000\">    </span><span style=\"color: #1A1A1A\">result</span><span style=\"color: #000000\">[</span><span style=\"color: #1A1A1A\">k</span><span style=\"color: #000000\">] = </span><span style=\"color: #1A1A1A\">t</span><span style=\"color: #000000\">[</span><span style=\"color: #1A1A1A\">k</span><span style=\"color: #000000\">].get();</span>\n<span style=\"color: #000000\">  }</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">result</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">originalProps </span><span style=\"color: #000000\">= unproxify(</span><span style=\"color: #1A1A1A\">proxyProps</span><span style=\"color: #000000\">);</span></code></div></pre>\n<p>Note that this unwrapping inference only works on homomorphic mapped types.\nIf the mapped type is not homomorphic you’ll have to give an explicit type parameter to your unwrapping function.</p>\n<h1 id=\"conditional-types\" style=\"position:relative;\"><a href=\"#conditional-types\" aria-label=\"conditional types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conditional Types</h1>\n<p>TypeScript 2.8 introduces <em>conditional types</em> which add the ability to express non-uniform type mappings.\nA conditional type selects one of two possible types based on a condition expressed as a type relationship test:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #000000\">T </span><span style=\"color: #1A1A1A\">extends</span><span style=\"color: #000000\"> U ? X : Y</span></code></div></pre>\n<p>The type above means when <code>T</code> is assignable to <code>U</code> the type is <code>X</code>, otherwise the type is <code>Y</code>.</p>\n<p>A conditional type <code>T extends U ? X : Y</code> is either <em>resolved</em> to <code>X</code> or <code>Y</code>, or <em>deferred</em> because the condition depends on one or more type variables.\nWhen <code>T</code> or <code>U</code> contains type variables, whether to resolve to <code>X</code> or <code>Y</code>, or to defer, is determined by whether or not the type system has enough information to conclude that <code>T</code> is always assignable to <code>U</code>.</p>\n<p>As an example of some types that are immediately resolved, we can take a look at the following example:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> f&lt;T </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> boolean&gt;(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: T): T extends true ? string : number;</span>\n\n<span style=\"color: #008000\">// Type is 'string | number'</span>\n<span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">x </span><span style=\"color: #000000\">= f(Math.random() &lt; </span><span style=\"color: #09835A\">0.5</span><span style=\"color: #000000\">);</span></code></div></pre>\n<p>Another example would be the <code>TypeName</code> type alias, which uses nested conditional types:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> TypeName&lt;T&gt; = T extends string</span>\n<span style=\"color: #000000\">  ? </span><span style=\"color: #A31515\">\"string\"</span>\n<span style=\"color: #000000\">  : T extends number</span>\n<span style=\"color: #000000\">  ? </span><span style=\"color: #A31515\">\"number\"</span>\n<span style=\"color: #000000\">  : T extends boolean</span>\n<span style=\"color: #000000\">  ? </span><span style=\"color: #A31515\">\"boolean\"</span>\n<span style=\"color: #000000\">  : T extends undefined</span>\n<span style=\"color: #000000\">  ? </span><span style=\"color: #A31515\">\"undefined\"</span>\n<span style=\"color: #000000\">  : T extends Function</span>\n<span style=\"color: #000000\">  ? </span><span style=\"color: #A31515\">\"function\"</span>\n<span style=\"color: #000000\">  : </span><span style=\"color: #A31515\">\"object\"</span><span style=\"color: #000000\">;</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T0 = TypeName&lt;string&gt;; </span><span style=\"color: #008000\">// \"string\"</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T1 = TypeName&lt;</span><span style=\"color: #A31515\">\"a\"</span><span style=\"color: #000000\">&gt;; </span><span style=\"color: #008000\">// \"string\"</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T2 = TypeName&lt;true&gt;; </span><span style=\"color: #008000\">// \"boolean\"</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T3 = TypeName&lt;() </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void&gt;; </span><span style=\"color: #008000\">// \"function\"</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T4 = TypeName&lt;string[]&gt;; </span><span style=\"color: #008000\">// \"object\"</span></code></div></pre>\n<p>But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Foo {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">propA</span><span style=\"color: #000000\">: boolean;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">propB</span><span style=\"color: #000000\">: boolean;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> f&lt;T&gt;(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: T): T extends Foo ? string : number;</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> foo&lt;U&gt;(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: U) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// Has type 'U extends Foo ? string : number'</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">a </span><span style=\"color: #000000\">= f(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">);</span>\n\n<span style=\"color: #000000\">  </span><span style=\"color: #008000\">// This assignment is allowed though!</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> string </span><span style=\"color: #000000\">|</span><span style=\"color: #1A1A1A\"> number </span><span style=\"color: #000000\">= </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>In the above, the variable <code>a</code> has a conditional type that hasn’t yet chosen a branch.\nWhen another piece of code ends up calling <code>foo</code>, it will substitute in <code>U</code> with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</p>\n<p>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target.\nSo in our example above we were able to assign <code>U extends Foo ? string : number</code> to <code>string | number</code> since no matter what the conditional evaluates to, it’s known to be either <code>string</code> or <code>number</code>.</p>\n<h2 id=\"distributive-conditional-types\" style=\"position:relative;\"><a href=\"#distributive-conditional-types\" aria-label=\"distributive conditional types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Distributive conditional types</h2>\n<p>Conditional types in which the checked type is a naked type parameter are called <em>distributive conditional types</em>.\nDistributive conditional types are automatically distributed over union types during instantiation.\nFor example, an instantiation of <code>T extends U ? X : Y</code> with the type argument <code>A | B | C</code> for <code>T</code> is resolved as <code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>.</p>\n<h3 id=\"example\" style=\"position:relative;\"><a href=\"#example\" aria-label=\"example permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Example</h3>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T10 = TypeName&lt;string | (() </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void)&gt;; </span><span style=\"color: #008000\">// \"string\" | \"function\"</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T12 = TypeName&lt;string | string[] | undefined&gt;; </span><span style=\"color: #008000\">// \"string\" | \"object\" | \"undefined\"</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T11 = TypeName&lt;string[] | number[]&gt;; </span><span style=\"color: #008000\">// \"object\"</span></code></div></pre>\n<p>In instantiations of a distributive conditional type <code>T extends U ? X : Y</code>, references to <code>T</code> within the conditional type are resolved to individual constituents of the union type (i.e. <code>T</code> refers to the individual constituents <em>after</em> the conditional type is distributed over the union type).\nFurthermore, references to <code>T</code> within <code>X</code> have an additional type parameter constraint <code>U</code> (i.e. <code>T</code> is considered assignable to <code>U</code> within <code>X</code>).</p>\n<h3 id=\"example-1\" style=\"position:relative;\"><a href=\"#example-1\" aria-label=\"example 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Example</h3>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> BoxedValue&lt;T&gt; = { </span><span style=\"color: #1A1A1A\">value</span><span style=\"color: #000000\">: T };</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> BoxedArray&lt;T&gt; = { </span><span style=\"color: #1A1A1A\">array</span><span style=\"color: #000000\">: T[] };</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Boxed&lt;T&gt; = T extends any[] ? BoxedArray&lt;T[number]&gt; : BoxedValue&lt;T&gt;;</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T20 = Boxed&lt;string&gt;; </span><span style=\"color: #008000\">// BoxedValue&lt;string&gt;;</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T21 = Boxed&lt;number[]&gt;; </span><span style=\"color: #008000\">// BoxedArray&lt;number&gt;;</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T22 = Boxed&lt;string | number[]&gt;; </span><span style=\"color: #008000\">// BoxedValue&lt;string&gt; | BoxedArray&lt;number&gt;;</span></code></div></pre>\n<p>Notice that <code>T</code> has the additional constraint <code>any[]</code> within the true branch of <code>Boxed&#x3C;T></code> and it is therefore possible to refer to the element type of the array as <code>T[number]</code>. Also, notice how the conditional type is distributed over the union type in the last example.</p>\n<p>The distributive property of conditional types can conveniently be used to <em>filter</em> union types:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Diff&lt;T, U&gt; = T extends U ? never : T; </span><span style=\"color: #008000\">// Remove types from T that are assignable to U</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Filter&lt;T, U&gt; = T extends U ? T : never; </span><span style=\"color: #008000\">// Remove types from T that are not assignable to U</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T30 = Diff&lt;</span><span style=\"color: #A31515\">\"a\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"b\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"c\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"d\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"a\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"c\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"f\"</span><span style=\"color: #000000\">&gt;; </span><span style=\"color: #008000\">// \"b\" | \"d\"</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T31 = Filter&lt;</span><span style=\"color: #A31515\">\"a\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"b\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"c\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"d\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"a\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"c\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"f\"</span><span style=\"color: #000000\">&gt;; </span><span style=\"color: #008000\">// \"a\" | \"c\"</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T32 = Diff&lt;string | number | (() </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void), Function&gt;; </span><span style=\"color: #008000\">// string | number</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T33 = Filter&lt;string | number | (() </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void), Function&gt;; </span><span style=\"color: #008000\">// () =&gt; void</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> NonNullable&lt;T&gt; = Diff&lt;T, null | undefined&gt;; </span><span style=\"color: #008000\">// Remove null and undefined from T</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T34 = NonNullable&lt;string | number | undefined&gt;; </span><span style=\"color: #008000\">// string | number</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T35 = NonNullable&lt;string | string[] | null | undefined&gt;; </span><span style=\"color: #008000\">// string | string[]</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> f1&lt;T&gt;(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: T, </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">: NonNullable&lt;T&gt;) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Ok</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Error</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> f2&lt;T </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> string | undefined&gt;(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: T, </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">: NonNullable&lt;T&gt;) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Ok</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\"> = </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Error</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s1</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> string </span><span style=\"color: #000000\">= </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Error</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">s2</span><span style=\"color: #000000\">:</span><span style=\"color: #1A1A1A\"> string </span><span style=\"color: #000000\">= </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Ok</span>\n<span style=\"color: #000000\">}</span></code></div></pre>\n<p>Conditional types are particularly useful when combined with mapped types:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> FunctionPropertyNames&lt;T&gt; = {</span>\n<span style=\"color: #000000\">  [K </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keyof</span><span style=\"color: #000000\"> T]: T[K] extends Function ? K : never;</span>\n<span style=\"color: #000000\">}[</span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #000000\"> T];</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> FunctionProperties&lt;T&gt; = Pick&lt;T, FunctionPropertyNames&lt;T&gt;&gt;;</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> NonFunctionPropertyNames&lt;T&gt; = {</span>\n<span style=\"color: #000000\">  [K </span><span style=\"color: #0000FF\">in</span><span style=\"color: #000000\"> </span><span style=\"color: #1A1A1A\">keyof</span><span style=\"color: #000000\"> T]: T[K] extends Function ? never : K;</span>\n<span style=\"color: #000000\">}[</span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #000000\"> T];</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> NonFunctionProperties&lt;T&gt; = Pick&lt;T, NonFunctionPropertyNames&lt;T&gt;&gt;;</span>\n\n<span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> Part {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">id</span><span style=\"color: #000000\">: number;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">name</span><span style=\"color: #000000\">: string;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">subparts</span><span style=\"color: #000000\">: Part[];</span>\n<span style=\"color: #000000\">  updatePart(</span><span style=\"color: #1A1A1A\">newName</span><span style=\"color: #000000\">: string): void;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T40 = FunctionPropertyNames&lt;Part&gt;; </span><span style=\"color: #008000\">// \"updatePart\"</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T41 = NonFunctionPropertyNames&lt;Part&gt;; </span><span style=\"color: #008000\">// \"id\" | \"name\" | \"subparts\"</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T42 = FunctionProperties&lt;Part&gt;; </span><span style=\"color: #008000\">// { updatePart(newName: string): void }</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T43 = NonFunctionProperties&lt;Part&gt;; </span><span style=\"color: #008000\">// { id: number, name: string, subparts: Part[] }</span></code></div></pre>\n<p>Similar to union and intersection types, conditional types are not permitted to reference themselves recursively.\nFor example the following is an error.</p>\n<h3 id=\"example-2\" style=\"position:relative;\"><a href=\"#example-2\" aria-label=\"example 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Example</h3>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> ElementType&lt;T&gt; = T extends any[] ? ElementType&lt;T[number]&gt; : T; </span><span style=\"color: #008000\">// Error</span></code></div></pre>\n<h2 id=\"type-inference-in-conditional-types\" style=\"position:relative;\"><a href=\"#type-inference-in-conditional-types\" aria-label=\"type inference in conditional types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Type inference in conditional types</h2>\n<p>Within the <code>extends</code> clause of a conditional type, it is now possible to have <code>infer</code> declarations that introduce a type variable to be inferred.\nSuch inferred type variables may be referenced in the true branch of the conditional type.\nIt is possible to have multiple <code>infer</code> locations for the same type variable.</p>\n<p>For example, the following extracts the return type of a function type:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> ReturnType&lt;T&gt; = T extends (...</span><span style=\"color: #1A1A1A\">args</span><span style=\"color: #000000\">: any[]) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> infer R ? R : any;</span></code></div></pre>\n<p>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Unpacked&lt;T&gt; = T extends (infer U)[]</span>\n<span style=\"color: #000000\">  ? U</span>\n<span style=\"color: #000000\">  : T extends (...</span><span style=\"color: #1A1A1A\">args</span><span style=\"color: #000000\">: any[]) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> infer U</span>\n<span style=\"color: #000000\">  ? U</span>\n<span style=\"color: #000000\">  : T extends Promise&lt;infer U&gt;</span>\n<span style=\"color: #000000\">  ? U</span>\n<span style=\"color: #000000\">  : T;</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T0 = Unpacked&lt;string&gt;; </span><span style=\"color: #008000\">// string</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T1 = Unpacked&lt;string[]&gt;; </span><span style=\"color: #008000\">// string</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T2 = Unpacked&lt;() </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> string&gt;; </span><span style=\"color: #008000\">// string</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T3 = Unpacked&lt;Promise&lt;string&gt;&gt;; </span><span style=\"color: #008000\">// string</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T4 = Unpacked&lt;Promise&lt;string&gt;[]&gt;; </span><span style=\"color: #008000\">// Promise&lt;string&gt;</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T5 = Unpacked&lt;Unpacked&lt;Promise&lt;string&gt;[]&gt;&gt;; </span><span style=\"color: #008000\">// string</span></code></div></pre>\n<p>The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Foo&lt;T&gt; = T extends { </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">: infer U; </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">: infer U } ? U : never;</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T10 = Foo&lt;{ </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">: string; </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">: string }&gt;; </span><span style=\"color: #008000\">// string</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T11 = Foo&lt;{ </span><span style=\"color: #1A1A1A\">a</span><span style=\"color: #000000\">: string; </span><span style=\"color: #1A1A1A\">b</span><span style=\"color: #000000\">: number }&gt;; </span><span style=\"color: #008000\">// string | number</span></code></div></pre>\n<p>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> Bar&lt;T&gt; = T extends { a: (</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: infer U) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void; b: (</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: infer U) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void }</span>\n<span style=\"color: #000000\">  ? U</span>\n<span style=\"color: #000000\">  : never;</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T20 = Bar&lt;{ a: (</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: string) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void; b: (</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: string) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void }&gt;; </span><span style=\"color: #008000\">// string</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T21 = Bar&lt;{ a: (</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: string) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void; b: (</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: number) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void }&gt;; </span><span style=\"color: #008000\">// string & number</span></code></div></pre>\n<p>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the <em>last</em> signature (which, presumably, is the most permissive catch-all case).\nIt is not possible to perform overload resolution based on a list of argument types.</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> foo(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: string): number;</span>\n<span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> foo(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: number): string;</span>\n<span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> foo(</span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\">: string | number): string | number;</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T30 = ReturnType&lt;</span><span style=\"color: #0000FF\">typeof</span><span style=\"color: #000000\"> foo&gt;; </span><span style=\"color: #008000\">// string | number</span></code></div></pre>\n<p>It is not possible to use <code>infer</code> declarations in constraint clauses for regular type parameters:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> ReturnType&lt;T </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> (...</span><span style=\"color: #1A1A1A\">args</span><span style=\"color: #000000\">: any[]) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> infer R&gt; = R; </span><span style=\"color: #008000\">// Error, not supported</span></code></div></pre>\n<p>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</p>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> AnyFunction = (...</span><span style=\"color: #1A1A1A\">args</span><span style=\"color: #000000\">: any[]) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> any;</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> ReturnType&lt;T </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> AnyFunction&gt; = T extends (...</span><span style=\"color: #1A1A1A\">args</span><span style=\"color: #000000\">: any[]) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> infer R</span>\n<span style=\"color: #000000\">  ? R</span>\n<span style=\"color: #000000\">  : any;</span></code></div></pre>\n<h2 id=\"predefined-conditional-types\" style=\"position:relative;\"><a href=\"#predefined-conditional-types\" aria-label=\"predefined conditional types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Predefined conditional types</h2>\n<p>TypeScript 2.8 adds several predefined conditional types to <code>lib.d.ts</code>:</p>\n<ul>\n<li><code>Exclude&#x3C;T, U></code> — Exclude from <code>T</code> those types that are assignable to <code>U</code>.</li>\n<li><code>Extract&#x3C;T, U></code> — Extract from <code>T</code> those types that are assignable to <code>U</code>.</li>\n<li><code>NonNullable&#x3C;T></code> — Exclude <code>null</code> and <code>undefined</code> from <code>T</code>.</li>\n<li><code>ReturnType&#x3C;T></code> — Obtain the return type of a function type.</li>\n<li><code>InstanceType&#x3C;T></code> — Obtain the instance type of a constructor function type.</li>\n</ul>\n<h3 id=\"example-3\" style=\"position:relative;\"><a href=\"#example-3\" aria-label=\"example 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Example</h3>\n<pre class=\"shiki\"><div class=\"language-id\">ts</div><div class='code-container'><code><span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T00 = Exclude&lt;</span><span style=\"color: #A31515\">\"a\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"b\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"c\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"d\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"a\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"c\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"f\"</span><span style=\"color: #000000\">&gt;; </span><span style=\"color: #008000\">// \"b\" | \"d\"</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T01 = Extract&lt;</span><span style=\"color: #A31515\">\"a\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"b\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"c\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"d\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"a\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"c\"</span><span style=\"color: #000000\"> | </span><span style=\"color: #A31515\">\"f\"</span><span style=\"color: #000000\">&gt;; </span><span style=\"color: #008000\">// \"a\" | \"c\"</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T02 = Exclude&lt;string | number | (() </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void), Function&gt;; </span><span style=\"color: #008000\">// string | number</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T03 = Extract&lt;string | number | (() </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void), Function&gt;; </span><span style=\"color: #008000\">// () =&gt; void</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T04 = NonNullable&lt;string | number | undefined&gt;; </span><span style=\"color: #008000\">// string | number</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T05 = NonNullable&lt;(() </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> string) | string[] | null | undefined&gt;; </span><span style=\"color: #008000\">// (() =&gt; string) | string[]</span>\n\n<span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> f1(</span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">: string) {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #0000FF\">return</span><span style=\"color: #000000\"> { a: </span><span style=\"color: #09835A\">1</span><span style=\"color: #000000\">, b: </span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\"> };</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> C {</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">x</span><span style=\"color: #000000\"> = </span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">  </span><span style=\"color: #1A1A1A\">y</span><span style=\"color: #000000\"> = </span><span style=\"color: #09835A\">0</span><span style=\"color: #000000\">;</span>\n<span style=\"color: #000000\">}</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T10 = ReturnType&lt;() </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> string&gt;; </span><span style=\"color: #008000\">// string</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T11 = ReturnType&lt;(</span><span style=\"color: #1A1A1A\">s</span><span style=\"color: #000000\">: string) </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> void&gt;; </span><span style=\"color: #008000\">// void</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T12 = ReturnType&lt;&lt;T&gt;() </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> T&gt;; </span><span style=\"color: #008000\">// {}</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T13 = ReturnType&lt;&lt;T </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> U, U </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> number[]&gt;() </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> T&gt;; </span><span style=\"color: #008000\">// number[]</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T14 = ReturnType&lt;</span><span style=\"color: #0000FF\">typeof</span><span style=\"color: #000000\"> f1&gt;; </span><span style=\"color: #008000\">// { a: number, b: string }</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T15 = ReturnType&lt;any&gt;; </span><span style=\"color: #008000\">// any</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T16 = ReturnType&lt;never&gt;; </span><span style=\"color: #008000\">// never</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T17 = ReturnType&lt;string&gt;; </span><span style=\"color: #008000\">// Error</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T18 = ReturnType&lt;Function&gt;; </span><span style=\"color: #008000\">// Error</span>\n\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T20 = InstanceType&lt;</span><span style=\"color: #0000FF\">typeof</span><span style=\"color: #000000\"> C&gt;; </span><span style=\"color: #008000\">// C</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T21 = InstanceType&lt;any&gt;; </span><span style=\"color: #008000\">// any</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T22 = InstanceType&lt;never&gt;; </span><span style=\"color: #008000\">// never</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T23 = InstanceType&lt;string&gt;; </span><span style=\"color: #008000\">// Error</span>\n<span style=\"color: #0000FF\">type</span><span style=\"color: #000000\"> T24 = InstanceType&lt;Function&gt;; </span><span style=\"color: #008000\">// Error</span></code></div></pre>\n<blockquote>\n<p>Note: The <code>Exclude</code> type is a proper implementation of the <code>Diff</code> type suggested <a href=\"https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458\">here</a>. We’ve used the name <code>Exclude</code> to avoid breaking existing code that defines a <code>Diff</code>, plus we feel that name better conveys the semantics of the type.</p>\n</blockquote>","headings":[{"value":"Type Guards and Differentiating Types","depth":1},{"value":"User-Defined Type Guards","depth":2},{"value":"Using type predicates","depth":3},{"value":"Using the in operator","depth":3},{"value":"typeof type guards","depth":2},{"value":"instanceof type guards","depth":2},{"value":"Nullable types","depth":1},{"value":"Optional parameters and properties","depth":2},{"value":"Type guards and type assertions","depth":2},{"value":"Type Aliases","depth":1},{"value":"Interfaces vs. Type Aliases","depth":2},{"value":"String Literal Types","depth":1},{"value":"Numeric Literal Types","depth":1},{"value":"Enum Member Types","depth":1},{"value":"Discriminated Unions","depth":1},{"value":"Exhaustiveness checking","depth":2},{"value":"Polymorphic this types","depth":1},{"value":"Index types","depth":1},{"value":"Index types and index signatures","depth":2},{"value":"Mapped types","depth":1},{"value":"Inference from mapped types","depth":2},{"value":"Conditional Types","depth":1},{"value":"Distributive conditional types","depth":2},{"value":"Example","depth":3},{"value":"Example","depth":3},{"value":"Example","depth":3},{"value":"Type inference in conditional types","depth":2},{"value":"Predefined conditional types","depth":2},{"value":"Example","depth":3}],"frontmatter":{"permalink":"/docs/handbook/advanced-types.html","title":"Advanced Types","disable_toc":null,"oneline":"Advanced concepts around types in TypeScript"}},"prev":null,"next":null},"pageContext":{"slug":"/docs/handbook/advanced-types.html","repoPath":"/packages/handbook-v1/en/Advanced Types.md","isOldHandbook":true,"lang":"en","modifiedTime":"2020-06-26T18:59:29.887Z"}}}